#!/usr/bin/env python3
"""
Main script for the PiTelemetry module.
Contains utility functions and main invocation code
Designed to be invoked from command line or from systemd
"""

import sys
from pitelemetry import TelemetryFactory, PiTemperature
from time import sleep
import argparse
import logging, logging.config
import yaml
import os
import threading
import signal
import keyboard, termios, tty

sensorTypes = {'temperature': 'PiTemperature', 'humidity': 'PiHumidity'}
log = ""

def sigcatch(signum, frame):
    """Primitive Signal Handler """

    if signum == signal.SIGTERM:
        log.info("SIGTERM received, shutting down")
        shutdown.set()


def getchar():
    """ Utility function to read a character from the keyboard """

    ch = ' '
    fd = sys.stdin.fileno()
    old_settings = termios.tcgetattr(fd)
    try:
        tty.setraw(sys.stdin.fileno())
        ch = sys.stdin.read(1)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
    return ch

def main(argv):
    """ Create and run a thread for each sensor being monitored """

    # Set default arguments and overide with command line arguments if provided
    parser = argparse.ArgumentParser()
    parser.add_argument("-c", "--configfile", default="/etc/pitelemetry.yaml",
            help="location of YAML configuration file (default: %(default)s")
    parser.add_argument("-l", "--loglevel", default="INFO",
            help="define logging level (default: %(default)s")

    args = parser.parse_args()

    # Initialise logging
    # Convert parser.loglevel to numeric logging level
    logging_level = getattr(logging, args.loglevel.upper(), None)
    if not isinstance(logging_level, int):
        raise ValueError('Invalid logging level: %s', loglevel)

    # Create Logger object
    logging.basicConfig(level=logging_level)

    # Open this module's logger
    log = logging.getLogger(__name__)
    log.info("pitelemetry started")

    # Get telemetry configuration if none provided
    with open(args.configfile, 'r') as configFile:
        try:
            config =yaml.safe_load(configFile)
        except yaml.YAMLError as exc:
            print(exc)
            exit(1)

    # Make sure we have the right sensor modules installed
    os.system('modprobe w1-gpio')
    os.system('modprobe w1-therm')

    # Set an event to catch a call to shutdown
    shutdown = threading.Event()
    shutdown.clear()

    #Catch SIGTERM
    signal.signal(signal.SIGTERM, sigcatch)

    # Parse the config and instantiate a thread for each sensor
    broker = config['broker']
    sensors = config['sensors']
    threads = {}
    telemetryObj = TelemetryFactory()

    i =0
    for sensor in sensors:
        if not (sensor['sensor'] is None):
            sensor = sensor['sensor']
        sensorType = sensorTypes[sensor['type']]
        threads[i] = telemetryObj.create(sensorType, broker, sensor, shutdown)
        threads[i].setName(sensor['name'])
        threads[i].setDaemon(True)
        threads[i].start()
        log.debug("Thread %s created and started",sensor['name'])
        i += 1

    while not shutdown.isSet():
        if sys.stdin.isatty():
            char = getchar()
            if char == "q":
                log.debug("shut down signalled from keyboard")
                shutdown.set()

        sleep(1)

    # Shutdown
    log.debug("Shutting down")
    for j in range(0,i-1):
        threads[j].join()
    log.info("Shutdown")

if __name__ == "__main__":
    main(sys.argv[1:])
