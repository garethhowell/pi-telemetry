#!/usr/bin/env python3
"""
Main script for the PiTelemetry module.
Contains utility functions and main invocation code
Designed to be invoked from command line or from systemd
"""

import sys
from pitelemetry import TelemetryFactory, PiTemperature
from time import sleep
import argparse
import logging, logging.config
import yaml
import os
import threading
import signal
import keyboard, termios, tty

sensorTypes = {'temperature': 'PiTemperature', 'humidity': 'PiHumidity'}
log = ""

def sigcatch(signum, frame):
    """Primitive Signal Handler """

    if signum == signal.SIGTERM:
        log.info("SIGTERM received, shutting down")
        shutdown.set()


def getchar():
    """ Utility function to read a character from the keyboard """

    ch = ' '
    fd = sys.stdin.fileno()
    old_settings = termios.tcgetattr(fd)
    try:
        tty.setraw(sys.stdin.fileno())
        ch = sys.stdin.read(1)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
    return ch

def setup_logging(
        default_path='/etc/pitelemetry_logging.yaml',
        default_level=logging.INFO,
        env_key='LOG_CFG'
):
    """
    Setup logging based on yaml configuration
    """
# TODO Tidy this up so logging configuration can be defined on command line and from a file

    path = default_path
    value = os.getenv(env_key, None)
    if value:
        path = value
    if os.path.exists(path):
        with open(path, 'rt') as f:
            config = yaml.safe_load(f.read())
        logging.config.dictConfig(config)
    else:
        logging.basicConfig(level=default_level)

def main(argv):
    """Create and run a thread for each sensor being monitored """

    # Set default arguments and overide with command line arguments if provided
    parser = argparse.ArgumentParser()
    parser.add_argument("-c", "--configfile", default="/etc/pitelemetry.yaml",
                        help="location of YAML configuration file")
    parser.add_argument("-L", "--logfile", default="./logfile",
                        help="location of logfile")
    parser.add_argument("-l", "--loglevel", default="INFO",
                        help="define logging level")

    # Get telemetry configuration if none provided
    with open(parser.configfile, 'r') as configFile:
        try:
            config =yaml.safe_load(configFile)
        except yaml.YAMLError as exc:
            print(exc)
            exit(1)

    # Initialise logging
    # Convert parser.loglevel to numeric logging level
    logging_level = getattr(logging, parser.loglevel.upper(), None)
    if not isinstance(numeric_level, int):
        raise ValueError('Invalid logging level: %s', loglevel)
    logging.basicConfig(filename=parser.logfile, level=logging_level)

    log = logging.getLogger("pitelemetry")
    log.info("pitelemetry started")

    # Make sure we have the right sensor modules installed
    os.system('modprobe w1-gpio')
    os.system('modprobe w1-therm')

    # Set an event to catch a call to shutdown
    shutdown = threading.Event()
    shutdown.clear()

    #Catch SIGTERM
    signal.signal(signal.SIGTERM, sigcatch)

    # Parse the config and instantiate a thread for each sensor
    broker = config['broker']
    sensors = config['sensors']
    threads = {}
    telemetryObj = TelemetryFactory()

    i =0
    for sensor in sensors:
        if not (sensor['sensor'] is None):
            sensor = sensor['sensor']
        sensorType = sensorTypes[sensor['type']]
        threads[i] = telemetryObj.create(sensorType, broker, sensor, shutdown)
        threads[i].setName(sensor['name'])
        threads[i].setDaemon(True)
        threads[i].start()
        log.debug("Thread %s created and started",sensor['name'])
        i += 1

    while not shutdown.isSet():
        if sys.stdin.isatty():
            char = getchar()
            if char == "q":
                log.debug("shut down signalled from keyboard")
                shutdown.set()

        sleep(1)

    # Shutdown
    log.debug("Shutting down")
    for j in range(0,i-1):
        threads[j].join()
    log.info("Shutdown")

if __name__ == "__main__":
    main(sys.argv[1:])
